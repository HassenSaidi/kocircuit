package model

import (
	"fmt"
	"path"
	"strings"

	. "github.com/kocircuit/kocircuit/lang/circuit/model"
	. "github.com/kocircuit/kocircuit/lang/go/kit/hash"
	. "github.com/kocircuit/kocircuit/lang/go/kit/tree"
)

type PkgGroup string

const (
	KoPkgGroup           = PkgGroup("ko") // package is generated by the Ko compiler
	GoHereditaryPkgGroup = PkgGroup("go") // package is derived during compile-time Go reflection
)

// GoGroupPath captures a package group (by identifier) and
// a package path within it (relative to its implied root).
type GoGroupPath struct {
	Group PkgGroup `ko:"name=group"`
	Path  string   `ko:"name=path"`
}

func (pkgGroup GoGroupPath) String() string {
	return fmt.Sprintf("%s//%s", string(pkgGroup.Group), pkgGroup.Path)
}

func (pkgGroup GoGroupPath) PkgName() string {
	return path.Base(pkgGroup.Path)
}

type GoAddress struct {
	Comment   string      `ko:"name=comment"`
	Span      *Span       `ko:"name=span"`
	GroupPath GoGroupPath `ko:"name=groupPath"`
	Name      string      `ko:"name=name"`
}

func (a *GoAddress) Label() Label {
	return Label{Path: a.GroupPath.String(), Name: a.Name}
}

func (a *GoAddress) Doc() string { return a.Comment }

func (a *GoAddress) String() string {
	return fmt.Sprintf("%v.%s", a.GroupPath, a.Name)
}

func (a *GoAddress) TypeID() string {
	return Mix("group", string(a.GroupPath.String()), "name", a.Name)
}
func (a *GoAddress) IsHereditary() bool {
	return a.GroupPath.Group == GoHereditaryPkgGroup
}

func (a *GoAddress) UnifiedName(fileCtx GoFileContext) string {
	return a.Name
}

func (a *GoAddress) UnifiedPkg(fileCtx GoFileContext) string {
	return fileCtx.UnifiedPath(a.GroupPath)
}

func (a *GoAddress) RenderExpr(fileCtx GoFileContext) string {
	if a.GroupPath == fileCtx.GroupPath() {
		return a.UnifiedName(fileCtx)
	}
	return fmt.Sprintf("%s.%s", fileCtx.Import(a.GroupPath), a.UnifiedName(fileCtx))
}

func (a *GoAddress) Filebase() string {
	return SpanFilebase(a.Span)
}

// SpanFilebase returns a filebase dependent on the span label path.
// It serves as a partition of types to files.
func SpanFilebase(span *Span) string {
	abbrevPath := span.LabelPath().Reverse()
	var p string
	if len(abbrevPath) > 7 {
		p = fmt.Sprintf(
			"%s+%s",
			strings.Join(abbrevPath[:7], "_"),
			Mix(strings.Join(abbrevPath[7:], "_")),
		)
	} else {
		p = strings.Join(abbrevPath, "_")
	}
	if len(p) > 100 {
		p = fmt.Sprintf("%s---%s", p[:40], Mix(p[40:]))
	}
	return p
}

func NewSpanAddress(origin *Span, kind string, forType GoType) *GoAddress {
	weavingLabel := NearestGoCtx(origin).Label()
	addr := &GoAddress{
		Comment:   fmt.Sprintf("%s %s", origin.CommentLine(), kind),
		Span:      origin,
		GroupPath: SpanGroupPath(origin),
		Name: fmt.Sprintf(
			"%s_%s_%s_%s_span_%s", // Func/Label_Variant_Step_Kind_TypeID_span_SpanID
			weavingLabel,
			NearestStep(origin).Label,
			kind,
			forType.TypeID(),
			origin.SpanID().String(),
		),
	}
	return addr
}
