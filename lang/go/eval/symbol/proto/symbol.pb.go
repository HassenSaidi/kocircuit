// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: symbol.proto

/*
	Package proto is a generated protocol buffer package.

	It is generated from these files:
		symbol.proto

	It has these top-level messages:
		Symbol
		SymbolEmpty
		SymbolBasic
		SymbolSeries
		SymbolStruct
		SymbolField
		SymbolMap
		SymbolKeyValue
		SymbolBlob
*/
package proto

import proto1 "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import binary "encoding/binary"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto1.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto1.ProtoPackageIsVersion2 // please upgrade the proto package

type Symbol struct {
	// Types that are valid to be assigned to Symbol:
	//	*Symbol_Empty
	//	*Symbol_Basic
	//	*Symbol_Series
	//	*Symbol_Struct
	//	*Symbol_Map
	//	*Symbol_Blob
	Symbol           isSymbol_Symbol `protobuf_oneof:"symbol"`
	XXX_unrecognized []byte          `json:"-"`
}

func (m *Symbol) Reset()                    { *m = Symbol{} }
func (m *Symbol) String() string            { return proto1.CompactTextString(m) }
func (*Symbol) ProtoMessage()               {}
func (*Symbol) Descriptor() ([]byte, []int) { return fileDescriptorSymbol, []int{0} }

type isSymbol_Symbol interface {
	isSymbol_Symbol()
	MarshalTo([]byte) (int, error)
	Size() int
}

type Symbol_Empty struct {
	Empty *SymbolEmpty `protobuf:"bytes,1,opt,name=empty,oneof"`
}
type Symbol_Basic struct {
	Basic *SymbolBasic `protobuf:"bytes,2,opt,name=basic,oneof"`
}
type Symbol_Series struct {
	Series *SymbolSeries `protobuf:"bytes,3,opt,name=series,oneof"`
}
type Symbol_Struct struct {
	Struct *SymbolStruct `protobuf:"bytes,4,opt,name=struct,oneof"`
}
type Symbol_Map struct {
	Map *SymbolMap `protobuf:"bytes,5,opt,name=map,oneof"`
}
type Symbol_Blob struct {
	Blob *SymbolBlob `protobuf:"bytes,6,opt,name=blob,oneof"`
}

func (*Symbol_Empty) isSymbol_Symbol()  {}
func (*Symbol_Basic) isSymbol_Symbol()  {}
func (*Symbol_Series) isSymbol_Symbol() {}
func (*Symbol_Struct) isSymbol_Symbol() {}
func (*Symbol_Map) isSymbol_Symbol()    {}
func (*Symbol_Blob) isSymbol_Symbol()   {}

func (m *Symbol) GetSymbol() isSymbol_Symbol {
	if m != nil {
		return m.Symbol
	}
	return nil
}

func (m *Symbol) GetEmpty() *SymbolEmpty {
	if x, ok := m.GetSymbol().(*Symbol_Empty); ok {
		return x.Empty
	}
	return nil
}

func (m *Symbol) GetBasic() *SymbolBasic {
	if x, ok := m.GetSymbol().(*Symbol_Basic); ok {
		return x.Basic
	}
	return nil
}

func (m *Symbol) GetSeries() *SymbolSeries {
	if x, ok := m.GetSymbol().(*Symbol_Series); ok {
		return x.Series
	}
	return nil
}

func (m *Symbol) GetStruct() *SymbolStruct {
	if x, ok := m.GetSymbol().(*Symbol_Struct); ok {
		return x.Struct
	}
	return nil
}

func (m *Symbol) GetMap() *SymbolMap {
	if x, ok := m.GetSymbol().(*Symbol_Map); ok {
		return x.Map
	}
	return nil
}

func (m *Symbol) GetBlob() *SymbolBlob {
	if x, ok := m.GetSymbol().(*Symbol_Blob); ok {
		return x.Blob
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*Symbol) XXX_OneofFuncs() (func(msg proto1.Message, b *proto1.Buffer) error, func(msg proto1.Message, tag, wire int, b *proto1.Buffer) (bool, error), func(msg proto1.Message) (n int), []interface{}) {
	return _Symbol_OneofMarshaler, _Symbol_OneofUnmarshaler, _Symbol_OneofSizer, []interface{}{
		(*Symbol_Empty)(nil),
		(*Symbol_Basic)(nil),
		(*Symbol_Series)(nil),
		(*Symbol_Struct)(nil),
		(*Symbol_Map)(nil),
		(*Symbol_Blob)(nil),
	}
}

func _Symbol_OneofMarshaler(msg proto1.Message, b *proto1.Buffer) error {
	m := msg.(*Symbol)
	// symbol
	switch x := m.Symbol.(type) {
	case *Symbol_Empty:
		_ = b.EncodeVarint(1<<3 | proto1.WireBytes)
		if err := b.EncodeMessage(x.Empty); err != nil {
			return err
		}
	case *Symbol_Basic:
		_ = b.EncodeVarint(2<<3 | proto1.WireBytes)
		if err := b.EncodeMessage(x.Basic); err != nil {
			return err
		}
	case *Symbol_Series:
		_ = b.EncodeVarint(3<<3 | proto1.WireBytes)
		if err := b.EncodeMessage(x.Series); err != nil {
			return err
		}
	case *Symbol_Struct:
		_ = b.EncodeVarint(4<<3 | proto1.WireBytes)
		if err := b.EncodeMessage(x.Struct); err != nil {
			return err
		}
	case *Symbol_Map:
		_ = b.EncodeVarint(5<<3 | proto1.WireBytes)
		if err := b.EncodeMessage(x.Map); err != nil {
			return err
		}
	case *Symbol_Blob:
		_ = b.EncodeVarint(6<<3 | proto1.WireBytes)
		if err := b.EncodeMessage(x.Blob); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("Symbol.Symbol has unexpected type %T", x)
	}
	return nil
}

func _Symbol_OneofUnmarshaler(msg proto1.Message, tag, wire int, b *proto1.Buffer) (bool, error) {
	m := msg.(*Symbol)
	switch tag {
	case 1: // symbol.empty
		if wire != proto1.WireBytes {
			return true, proto1.ErrInternalBadWireType
		}
		msg := new(SymbolEmpty)
		err := b.DecodeMessage(msg)
		m.Symbol = &Symbol_Empty{msg}
		return true, err
	case 2: // symbol.basic
		if wire != proto1.WireBytes {
			return true, proto1.ErrInternalBadWireType
		}
		msg := new(SymbolBasic)
		err := b.DecodeMessage(msg)
		m.Symbol = &Symbol_Basic{msg}
		return true, err
	case 3: // symbol.series
		if wire != proto1.WireBytes {
			return true, proto1.ErrInternalBadWireType
		}
		msg := new(SymbolSeries)
		err := b.DecodeMessage(msg)
		m.Symbol = &Symbol_Series{msg}
		return true, err
	case 4: // symbol.struct
		if wire != proto1.WireBytes {
			return true, proto1.ErrInternalBadWireType
		}
		msg := new(SymbolStruct)
		err := b.DecodeMessage(msg)
		m.Symbol = &Symbol_Struct{msg}
		return true, err
	case 5: // symbol.map
		if wire != proto1.WireBytes {
			return true, proto1.ErrInternalBadWireType
		}
		msg := new(SymbolMap)
		err := b.DecodeMessage(msg)
		m.Symbol = &Symbol_Map{msg}
		return true, err
	case 6: // symbol.blob
		if wire != proto1.WireBytes {
			return true, proto1.ErrInternalBadWireType
		}
		msg := new(SymbolBlob)
		err := b.DecodeMessage(msg)
		m.Symbol = &Symbol_Blob{msg}
		return true, err
	default:
		return false, nil
	}
}

func _Symbol_OneofSizer(msg proto1.Message) (n int) {
	m := msg.(*Symbol)
	// symbol
	switch x := m.Symbol.(type) {
	case *Symbol_Empty:
		s := proto1.Size(x.Empty)
		n += proto1.SizeVarint(1<<3 | proto1.WireBytes)
		n += proto1.SizeVarint(uint64(s))
		n += s
	case *Symbol_Basic:
		s := proto1.Size(x.Basic)
		n += proto1.SizeVarint(2<<3 | proto1.WireBytes)
		n += proto1.SizeVarint(uint64(s))
		n += s
	case *Symbol_Series:
		s := proto1.Size(x.Series)
		n += proto1.SizeVarint(3<<3 | proto1.WireBytes)
		n += proto1.SizeVarint(uint64(s))
		n += s
	case *Symbol_Struct:
		s := proto1.Size(x.Struct)
		n += proto1.SizeVarint(4<<3 | proto1.WireBytes)
		n += proto1.SizeVarint(uint64(s))
		n += s
	case *Symbol_Map:
		s := proto1.Size(x.Map)
		n += proto1.SizeVarint(5<<3 | proto1.WireBytes)
		n += proto1.SizeVarint(uint64(s))
		n += s
	case *Symbol_Blob:
		s := proto1.Size(x.Blob)
		n += proto1.SizeVarint(6<<3 | proto1.WireBytes)
		n += proto1.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type SymbolEmpty struct {
	XXX_unrecognized []byte `json:"-"`
}

func (m *SymbolEmpty) Reset()                    { *m = SymbolEmpty{} }
func (m *SymbolEmpty) String() string            { return proto1.CompactTextString(m) }
func (*SymbolEmpty) ProtoMessage()               {}
func (*SymbolEmpty) Descriptor() ([]byte, []int) { return fileDescriptorSymbol, []int{1} }

type SymbolBasic struct {
	// Types that are valid to be assigned to Basic:
	//	*SymbolBasic_Bool
	//	*SymbolBasic_String_
	//	*SymbolBasic_Int8
	//	*SymbolBasic_Int16
	//	*SymbolBasic_Int32
	//	*SymbolBasic_Int64
	//	*SymbolBasic_Uint8
	//	*SymbolBasic_Uint16
	//	*SymbolBasic_Uint32
	//	*SymbolBasic_Uint64
	//	*SymbolBasic_Float32
	//	*SymbolBasic_Float64
	Basic            isSymbolBasic_Basic `protobuf_oneof:"basic"`
	XXX_unrecognized []byte              `json:"-"`
}

func (m *SymbolBasic) Reset()                    { *m = SymbolBasic{} }
func (m *SymbolBasic) String() string            { return proto1.CompactTextString(m) }
func (*SymbolBasic) ProtoMessage()               {}
func (*SymbolBasic) Descriptor() ([]byte, []int) { return fileDescriptorSymbol, []int{2} }

type isSymbolBasic_Basic interface {
	isSymbolBasic_Basic()
	MarshalTo([]byte) (int, error)
	Size() int
}

type SymbolBasic_Bool struct {
	Bool bool `protobuf:"varint,1,opt,name=bool,oneof"`
}
type SymbolBasic_String_ struct {
	String_ string `protobuf:"bytes,2,opt,name=string,oneof"`
}
type SymbolBasic_Int8 struct {
	Int8 int32 `protobuf:"varint,10,opt,name=int8,oneof"`
}
type SymbolBasic_Int16 struct {
	Int16 int32 `protobuf:"varint,11,opt,name=int16,oneof"`
}
type SymbolBasic_Int32 struct {
	Int32 int32 `protobuf:"varint,12,opt,name=int32,oneof"`
}
type SymbolBasic_Int64 struct {
	Int64 int64 `protobuf:"varint,13,opt,name=int64,oneof"`
}
type SymbolBasic_Uint8 struct {
	Uint8 uint32 `protobuf:"varint,20,opt,name=uint8,oneof"`
}
type SymbolBasic_Uint16 struct {
	Uint16 uint32 `protobuf:"varint,21,opt,name=uint16,oneof"`
}
type SymbolBasic_Uint32 struct {
	Uint32 uint32 `protobuf:"varint,22,opt,name=uint32,oneof"`
}
type SymbolBasic_Uint64 struct {
	Uint64 uint64 `protobuf:"varint,23,opt,name=uint64,oneof"`
}
type SymbolBasic_Float32 struct {
	Float32 float32 `protobuf:"fixed32,30,opt,name=float32,oneof"`
}
type SymbolBasic_Float64 struct {
	Float64 float64 `protobuf:"fixed64,31,opt,name=float64,oneof"`
}

func (*SymbolBasic_Bool) isSymbolBasic_Basic()    {}
func (*SymbolBasic_String_) isSymbolBasic_Basic() {}
func (*SymbolBasic_Int8) isSymbolBasic_Basic()    {}
func (*SymbolBasic_Int16) isSymbolBasic_Basic()   {}
func (*SymbolBasic_Int32) isSymbolBasic_Basic()   {}
func (*SymbolBasic_Int64) isSymbolBasic_Basic()   {}
func (*SymbolBasic_Uint8) isSymbolBasic_Basic()   {}
func (*SymbolBasic_Uint16) isSymbolBasic_Basic()  {}
func (*SymbolBasic_Uint32) isSymbolBasic_Basic()  {}
func (*SymbolBasic_Uint64) isSymbolBasic_Basic()  {}
func (*SymbolBasic_Float32) isSymbolBasic_Basic() {}
func (*SymbolBasic_Float64) isSymbolBasic_Basic() {}

func (m *SymbolBasic) GetBasic() isSymbolBasic_Basic {
	if m != nil {
		return m.Basic
	}
	return nil
}

func (m *SymbolBasic) GetBool() bool {
	if x, ok := m.GetBasic().(*SymbolBasic_Bool); ok {
		return x.Bool
	}
	return false
}

func (m *SymbolBasic) GetString_() string {
	if x, ok := m.GetBasic().(*SymbolBasic_String_); ok {
		return x.String_
	}
	return ""
}

func (m *SymbolBasic) GetInt8() int32 {
	if x, ok := m.GetBasic().(*SymbolBasic_Int8); ok {
		return x.Int8
	}
	return 0
}

func (m *SymbolBasic) GetInt16() int32 {
	if x, ok := m.GetBasic().(*SymbolBasic_Int16); ok {
		return x.Int16
	}
	return 0
}

func (m *SymbolBasic) GetInt32() int32 {
	if x, ok := m.GetBasic().(*SymbolBasic_Int32); ok {
		return x.Int32
	}
	return 0
}

func (m *SymbolBasic) GetInt64() int64 {
	if x, ok := m.GetBasic().(*SymbolBasic_Int64); ok {
		return x.Int64
	}
	return 0
}

func (m *SymbolBasic) GetUint8() uint32 {
	if x, ok := m.GetBasic().(*SymbolBasic_Uint8); ok {
		return x.Uint8
	}
	return 0
}

func (m *SymbolBasic) GetUint16() uint32 {
	if x, ok := m.GetBasic().(*SymbolBasic_Uint16); ok {
		return x.Uint16
	}
	return 0
}

func (m *SymbolBasic) GetUint32() uint32 {
	if x, ok := m.GetBasic().(*SymbolBasic_Uint32); ok {
		return x.Uint32
	}
	return 0
}

func (m *SymbolBasic) GetUint64() uint64 {
	if x, ok := m.GetBasic().(*SymbolBasic_Uint64); ok {
		return x.Uint64
	}
	return 0
}

func (m *SymbolBasic) GetFloat32() float32 {
	if x, ok := m.GetBasic().(*SymbolBasic_Float32); ok {
		return x.Float32
	}
	return 0
}

func (m *SymbolBasic) GetFloat64() float64 {
	if x, ok := m.GetBasic().(*SymbolBasic_Float64); ok {
		return x.Float64
	}
	return 0
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*SymbolBasic) XXX_OneofFuncs() (func(msg proto1.Message, b *proto1.Buffer) error, func(msg proto1.Message, tag, wire int, b *proto1.Buffer) (bool, error), func(msg proto1.Message) (n int), []interface{}) {
	return _SymbolBasic_OneofMarshaler, _SymbolBasic_OneofUnmarshaler, _SymbolBasic_OneofSizer, []interface{}{
		(*SymbolBasic_Bool)(nil),
		(*SymbolBasic_String_)(nil),
		(*SymbolBasic_Int8)(nil),
		(*SymbolBasic_Int16)(nil),
		(*SymbolBasic_Int32)(nil),
		(*SymbolBasic_Int64)(nil),
		(*SymbolBasic_Uint8)(nil),
		(*SymbolBasic_Uint16)(nil),
		(*SymbolBasic_Uint32)(nil),
		(*SymbolBasic_Uint64)(nil),
		(*SymbolBasic_Float32)(nil),
		(*SymbolBasic_Float64)(nil),
	}
}

func _SymbolBasic_OneofMarshaler(msg proto1.Message, b *proto1.Buffer) error {
	m := msg.(*SymbolBasic)
	// basic
	switch x := m.Basic.(type) {
	case *SymbolBasic_Bool:
		t := uint64(0)
		if x.Bool {
			t = 1
		}
		_ = b.EncodeVarint(1<<3 | proto1.WireVarint)
		_ = b.EncodeVarint(t)
	case *SymbolBasic_String_:
		_ = b.EncodeVarint(2<<3 | proto1.WireBytes)
		_ = b.EncodeStringBytes(x.String_)
	case *SymbolBasic_Int8:
		_ = b.EncodeVarint(10<<3 | proto1.WireVarint)
		_ = b.EncodeVarint(uint64(x.Int8))
	case *SymbolBasic_Int16:
		_ = b.EncodeVarint(11<<3 | proto1.WireVarint)
		_ = b.EncodeVarint(uint64(x.Int16))
	case *SymbolBasic_Int32:
		_ = b.EncodeVarint(12<<3 | proto1.WireVarint)
		_ = b.EncodeVarint(uint64(x.Int32))
	case *SymbolBasic_Int64:
		_ = b.EncodeVarint(13<<3 | proto1.WireVarint)
		_ = b.EncodeVarint(uint64(x.Int64))
	case *SymbolBasic_Uint8:
		_ = b.EncodeVarint(20<<3 | proto1.WireVarint)
		_ = b.EncodeVarint(uint64(x.Uint8))
	case *SymbolBasic_Uint16:
		_ = b.EncodeVarint(21<<3 | proto1.WireVarint)
		_ = b.EncodeVarint(uint64(x.Uint16))
	case *SymbolBasic_Uint32:
		_ = b.EncodeVarint(22<<3 | proto1.WireVarint)
		_ = b.EncodeVarint(uint64(x.Uint32))
	case *SymbolBasic_Uint64:
		_ = b.EncodeVarint(23<<3 | proto1.WireVarint)
		_ = b.EncodeVarint(uint64(x.Uint64))
	case *SymbolBasic_Float32:
		_ = b.EncodeVarint(30<<3 | proto1.WireFixed32)
		_ = b.EncodeFixed32(uint64(math.Float32bits(x.Float32)))
	case *SymbolBasic_Float64:
		_ = b.EncodeVarint(31<<3 | proto1.WireFixed64)
		_ = b.EncodeFixed64(math.Float64bits(x.Float64))
	case nil:
	default:
		return fmt.Errorf("SymbolBasic.Basic has unexpected type %T", x)
	}
	return nil
}

func _SymbolBasic_OneofUnmarshaler(msg proto1.Message, tag, wire int, b *proto1.Buffer) (bool, error) {
	m := msg.(*SymbolBasic)
	switch tag {
	case 1: // basic.bool
		if wire != proto1.WireVarint {
			return true, proto1.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.Basic = &SymbolBasic_Bool{x != 0}
		return true, err
	case 2: // basic.string
		if wire != proto1.WireBytes {
			return true, proto1.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.Basic = &SymbolBasic_String_{x}
		return true, err
	case 10: // basic.int8
		if wire != proto1.WireVarint {
			return true, proto1.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.Basic = &SymbolBasic_Int8{int32(x)}
		return true, err
	case 11: // basic.int16
		if wire != proto1.WireVarint {
			return true, proto1.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.Basic = &SymbolBasic_Int16{int32(x)}
		return true, err
	case 12: // basic.int32
		if wire != proto1.WireVarint {
			return true, proto1.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.Basic = &SymbolBasic_Int32{int32(x)}
		return true, err
	case 13: // basic.int64
		if wire != proto1.WireVarint {
			return true, proto1.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.Basic = &SymbolBasic_Int64{int64(x)}
		return true, err
	case 20: // basic.uint8
		if wire != proto1.WireVarint {
			return true, proto1.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.Basic = &SymbolBasic_Uint8{uint32(x)}
		return true, err
	case 21: // basic.uint16
		if wire != proto1.WireVarint {
			return true, proto1.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.Basic = &SymbolBasic_Uint16{uint32(x)}
		return true, err
	case 22: // basic.uint32
		if wire != proto1.WireVarint {
			return true, proto1.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.Basic = &SymbolBasic_Uint32{uint32(x)}
		return true, err
	case 23: // basic.uint64
		if wire != proto1.WireVarint {
			return true, proto1.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.Basic = &SymbolBasic_Uint64{x}
		return true, err
	case 30: // basic.float32
		if wire != proto1.WireFixed32 {
			return true, proto1.ErrInternalBadWireType
		}
		x, err := b.DecodeFixed32()
		m.Basic = &SymbolBasic_Float32{math.Float32frombits(uint32(x))}
		return true, err
	case 31: // basic.float64
		if wire != proto1.WireFixed64 {
			return true, proto1.ErrInternalBadWireType
		}
		x, err := b.DecodeFixed64()
		m.Basic = &SymbolBasic_Float64{math.Float64frombits(x)}
		return true, err
	default:
		return false, nil
	}
}

func _SymbolBasic_OneofSizer(msg proto1.Message) (n int) {
	m := msg.(*SymbolBasic)
	// basic
	switch x := m.Basic.(type) {
	case *SymbolBasic_Bool:
		n += proto1.SizeVarint(1<<3 | proto1.WireVarint)
		n += 1
	case *SymbolBasic_String_:
		n += proto1.SizeVarint(2<<3 | proto1.WireBytes)
		n += proto1.SizeVarint(uint64(len(x.String_)))
		n += len(x.String_)
	case *SymbolBasic_Int8:
		n += proto1.SizeVarint(10<<3 | proto1.WireVarint)
		n += proto1.SizeVarint(uint64(x.Int8))
	case *SymbolBasic_Int16:
		n += proto1.SizeVarint(11<<3 | proto1.WireVarint)
		n += proto1.SizeVarint(uint64(x.Int16))
	case *SymbolBasic_Int32:
		n += proto1.SizeVarint(12<<3 | proto1.WireVarint)
		n += proto1.SizeVarint(uint64(x.Int32))
	case *SymbolBasic_Int64:
		n += proto1.SizeVarint(13<<3 | proto1.WireVarint)
		n += proto1.SizeVarint(uint64(x.Int64))
	case *SymbolBasic_Uint8:
		n += proto1.SizeVarint(20<<3 | proto1.WireVarint)
		n += proto1.SizeVarint(uint64(x.Uint8))
	case *SymbolBasic_Uint16:
		n += proto1.SizeVarint(21<<3 | proto1.WireVarint)
		n += proto1.SizeVarint(uint64(x.Uint16))
	case *SymbolBasic_Uint32:
		n += proto1.SizeVarint(22<<3 | proto1.WireVarint)
		n += proto1.SizeVarint(uint64(x.Uint32))
	case *SymbolBasic_Uint64:
		n += proto1.SizeVarint(23<<3 | proto1.WireVarint)
		n += proto1.SizeVarint(uint64(x.Uint64))
	case *SymbolBasic_Float32:
		n += proto1.SizeVarint(30<<3 | proto1.WireFixed32)
		n += 4
	case *SymbolBasic_Float64:
		n += proto1.SizeVarint(31<<3 | proto1.WireFixed64)
		n += 8
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type SymbolSeries struct {
	Element          []*Symbol `protobuf:"bytes,1,rep,name=element" json:"element,omitempty"`
	XXX_unrecognized []byte    `json:"-"`
}

func (m *SymbolSeries) Reset()                    { *m = SymbolSeries{} }
func (m *SymbolSeries) String() string            { return proto1.CompactTextString(m) }
func (*SymbolSeries) ProtoMessage()               {}
func (*SymbolSeries) Descriptor() ([]byte, []int) { return fileDescriptorSymbol, []int{3} }

func (m *SymbolSeries) GetElement() []*Symbol {
	if m != nil {
		return m.Element
	}
	return nil
}

type SymbolStruct struct {
	Field            []*SymbolField `protobuf:"bytes,1,rep,name=field" json:"field,omitempty"`
	XXX_unrecognized []byte         `json:"-"`
}

func (m *SymbolStruct) Reset()                    { *m = SymbolStruct{} }
func (m *SymbolStruct) String() string            { return proto1.CompactTextString(m) }
func (*SymbolStruct) ProtoMessage()               {}
func (*SymbolStruct) Descriptor() ([]byte, []int) { return fileDescriptorSymbol, []int{4} }

func (m *SymbolStruct) GetField() []*SymbolField {
	if m != nil {
		return m.Field
	}
	return nil
}

type SymbolField struct {
	Name             *string `protobuf:"bytes,1,req,name=name" json:"name,omitempty"`
	Monadic          *bool   `protobuf:"varint,2,req,name=monadic" json:"monadic,omitempty"`
	Value            *Symbol `protobuf:"bytes,3,opt,name=value" json:"value,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *SymbolField) Reset()                    { *m = SymbolField{} }
func (m *SymbolField) String() string            { return proto1.CompactTextString(m) }
func (*SymbolField) ProtoMessage()               {}
func (*SymbolField) Descriptor() ([]byte, []int) { return fileDescriptorSymbol, []int{5} }

func (m *SymbolField) GetName() string {
	if m != nil && m.Name != nil {
		return *m.Name
	}
	return ""
}

func (m *SymbolField) GetMonadic() bool {
	if m != nil && m.Monadic != nil {
		return *m.Monadic
	}
	return false
}

func (m *SymbolField) GetValue() *Symbol {
	if m != nil {
		return m.Value
	}
	return nil
}

type SymbolMap struct {
	KeyValue         []*SymbolKeyValue `protobuf:"bytes,1,rep,name=key_value,json=keyValue" json:"key_value,omitempty"`
	XXX_unrecognized []byte            `json:"-"`
}

func (m *SymbolMap) Reset()                    { *m = SymbolMap{} }
func (m *SymbolMap) String() string            { return proto1.CompactTextString(m) }
func (*SymbolMap) ProtoMessage()               {}
func (*SymbolMap) Descriptor() ([]byte, []int) { return fileDescriptorSymbol, []int{6} }

func (m *SymbolMap) GetKeyValue() []*SymbolKeyValue {
	if m != nil {
		return m.KeyValue
	}
	return nil
}

type SymbolKeyValue struct {
	Key              *string `protobuf:"bytes,1,req,name=key" json:"key,omitempty"`
	Value            *Symbol `protobuf:"bytes,2,req,name=value" json:"value,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *SymbolKeyValue) Reset()                    { *m = SymbolKeyValue{} }
func (m *SymbolKeyValue) String() string            { return proto1.CompactTextString(m) }
func (*SymbolKeyValue) ProtoMessage()               {}
func (*SymbolKeyValue) Descriptor() ([]byte, []int) { return fileDescriptorSymbol, []int{7} }

func (m *SymbolKeyValue) GetKey() string {
	if m != nil && m.Key != nil {
		return *m.Key
	}
	return ""
}

func (m *SymbolKeyValue) GetValue() *Symbol {
	if m != nil {
		return m.Value
	}
	return nil
}

type SymbolBlob struct {
	Bytes            []byte `protobuf:"bytes,1,req,name=bytes" json:"bytes,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *SymbolBlob) Reset()                    { *m = SymbolBlob{} }
func (m *SymbolBlob) String() string            { return proto1.CompactTextString(m) }
func (*SymbolBlob) ProtoMessage()               {}
func (*SymbolBlob) Descriptor() ([]byte, []int) { return fileDescriptorSymbol, []int{8} }

func (m *SymbolBlob) GetBytes() []byte {
	if m != nil {
		return m.Bytes
	}
	return nil
}

func init() {
	proto1.RegisterType((*Symbol)(nil), "ko.symbol.Symbol")
	proto1.RegisterType((*SymbolEmpty)(nil), "ko.symbol.SymbolEmpty")
	proto1.RegisterType((*SymbolBasic)(nil), "ko.symbol.SymbolBasic")
	proto1.RegisterType((*SymbolSeries)(nil), "ko.symbol.SymbolSeries")
	proto1.RegisterType((*SymbolStruct)(nil), "ko.symbol.SymbolStruct")
	proto1.RegisterType((*SymbolField)(nil), "ko.symbol.SymbolField")
	proto1.RegisterType((*SymbolMap)(nil), "ko.symbol.SymbolMap")
	proto1.RegisterType((*SymbolKeyValue)(nil), "ko.symbol.SymbolKeyValue")
	proto1.RegisterType((*SymbolBlob)(nil), "ko.symbol.SymbolBlob")
}
func (m *Symbol) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Symbol) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Symbol != nil {
		nn1, err := m.Symbol.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn1
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Symbol_Empty) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Empty != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintSymbol(dAtA, i, uint64(m.Empty.Size()))
		n2, err := m.Empty.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	return i, nil
}
func (m *Symbol_Basic) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Basic != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintSymbol(dAtA, i, uint64(m.Basic.Size()))
		n3, err := m.Basic.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	return i, nil
}
func (m *Symbol_Series) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Series != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintSymbol(dAtA, i, uint64(m.Series.Size()))
		n4, err := m.Series.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	return i, nil
}
func (m *Symbol_Struct) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Struct != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintSymbol(dAtA, i, uint64(m.Struct.Size()))
		n5, err := m.Struct.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	return i, nil
}
func (m *Symbol_Map) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Map != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintSymbol(dAtA, i, uint64(m.Map.Size()))
		n6, err := m.Map.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n6
	}
	return i, nil
}
func (m *Symbol_Blob) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Blob != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintSymbol(dAtA, i, uint64(m.Blob.Size()))
		n7, err := m.Blob.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n7
	}
	return i, nil
}
func (m *SymbolEmpty) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SymbolEmpty) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *SymbolBasic) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SymbolBasic) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Basic != nil {
		nn8, err := m.Basic.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn8
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *SymbolBasic_Bool) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0x8
	i++
	if m.Bool {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	return i, nil
}
func (m *SymbolBasic_String_) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0x12
	i++
	i = encodeVarintSymbol(dAtA, i, uint64(len(m.String_)))
	i += copy(dAtA[i:], m.String_)
	return i, nil
}
func (m *SymbolBasic_Int8) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0x50
	i++
	i = encodeVarintSymbol(dAtA, i, uint64(m.Int8))
	return i, nil
}
func (m *SymbolBasic_Int16) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0x58
	i++
	i = encodeVarintSymbol(dAtA, i, uint64(m.Int16))
	return i, nil
}
func (m *SymbolBasic_Int32) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0x60
	i++
	i = encodeVarintSymbol(dAtA, i, uint64(m.Int32))
	return i, nil
}
func (m *SymbolBasic_Int64) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0x68
	i++
	i = encodeVarintSymbol(dAtA, i, uint64(m.Int64))
	return i, nil
}
func (m *SymbolBasic_Uint8) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0xa0
	i++
	dAtA[i] = 0x1
	i++
	i = encodeVarintSymbol(dAtA, i, uint64(m.Uint8))
	return i, nil
}
func (m *SymbolBasic_Uint16) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0xa8
	i++
	dAtA[i] = 0x1
	i++
	i = encodeVarintSymbol(dAtA, i, uint64(m.Uint16))
	return i, nil
}
func (m *SymbolBasic_Uint32) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0xb0
	i++
	dAtA[i] = 0x1
	i++
	i = encodeVarintSymbol(dAtA, i, uint64(m.Uint32))
	return i, nil
}
func (m *SymbolBasic_Uint64) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0xb8
	i++
	dAtA[i] = 0x1
	i++
	i = encodeVarintSymbol(dAtA, i, uint64(m.Uint64))
	return i, nil
}
func (m *SymbolBasic_Float32) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0xf5
	i++
	dAtA[i] = 0x1
	i++
	binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Float32))))
	i += 4
	return i, nil
}
func (m *SymbolBasic_Float64) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0xf9
	i++
	dAtA[i] = 0x1
	i++
	binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Float64))))
	i += 8
	return i, nil
}
func (m *SymbolSeries) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SymbolSeries) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Element) > 0 {
		for _, msg := range m.Element {
			dAtA[i] = 0xa
			i++
			i = encodeVarintSymbol(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *SymbolStruct) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SymbolStruct) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Field) > 0 {
		for _, msg := range m.Field {
			dAtA[i] = 0xa
			i++
			i = encodeVarintSymbol(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *SymbolField) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SymbolField) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Name == nil {
		return 0, new(proto1.RequiredNotSetError)
	} else {
		dAtA[i] = 0xa
		i++
		i = encodeVarintSymbol(dAtA, i, uint64(len(*m.Name)))
		i += copy(dAtA[i:], *m.Name)
	}
	if m.Monadic == nil {
		return 0, new(proto1.RequiredNotSetError)
	} else {
		dAtA[i] = 0x10
		i++
		if *m.Monadic {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Value != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintSymbol(dAtA, i, uint64(m.Value.Size()))
		n9, err := m.Value.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n9
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *SymbolMap) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SymbolMap) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.KeyValue) > 0 {
		for _, msg := range m.KeyValue {
			dAtA[i] = 0xa
			i++
			i = encodeVarintSymbol(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *SymbolKeyValue) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SymbolKeyValue) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Key == nil {
		return 0, new(proto1.RequiredNotSetError)
	} else {
		dAtA[i] = 0xa
		i++
		i = encodeVarintSymbol(dAtA, i, uint64(len(*m.Key)))
		i += copy(dAtA[i:], *m.Key)
	}
	if m.Value == nil {
		return 0, new(proto1.RequiredNotSetError)
	} else {
		dAtA[i] = 0x12
		i++
		i = encodeVarintSymbol(dAtA, i, uint64(m.Value.Size()))
		n10, err := m.Value.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n10
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *SymbolBlob) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SymbolBlob) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Bytes == nil {
		return 0, new(proto1.RequiredNotSetError)
	} else {
		dAtA[i] = 0xa
		i++
		i = encodeVarintSymbol(dAtA, i, uint64(len(m.Bytes)))
		i += copy(dAtA[i:], m.Bytes)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func encodeVarintSymbol(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *Symbol) Size() (n int) {
	var l int
	_ = l
	if m.Symbol != nil {
		n += m.Symbol.Size()
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Symbol_Empty) Size() (n int) {
	var l int
	_ = l
	if m.Empty != nil {
		l = m.Empty.Size()
		n += 1 + l + sovSymbol(uint64(l))
	}
	return n
}
func (m *Symbol_Basic) Size() (n int) {
	var l int
	_ = l
	if m.Basic != nil {
		l = m.Basic.Size()
		n += 1 + l + sovSymbol(uint64(l))
	}
	return n
}
func (m *Symbol_Series) Size() (n int) {
	var l int
	_ = l
	if m.Series != nil {
		l = m.Series.Size()
		n += 1 + l + sovSymbol(uint64(l))
	}
	return n
}
func (m *Symbol_Struct) Size() (n int) {
	var l int
	_ = l
	if m.Struct != nil {
		l = m.Struct.Size()
		n += 1 + l + sovSymbol(uint64(l))
	}
	return n
}
func (m *Symbol_Map) Size() (n int) {
	var l int
	_ = l
	if m.Map != nil {
		l = m.Map.Size()
		n += 1 + l + sovSymbol(uint64(l))
	}
	return n
}
func (m *Symbol_Blob) Size() (n int) {
	var l int
	_ = l
	if m.Blob != nil {
		l = m.Blob.Size()
		n += 1 + l + sovSymbol(uint64(l))
	}
	return n
}
func (m *SymbolEmpty) Size() (n int) {
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SymbolBasic) Size() (n int) {
	var l int
	_ = l
	if m.Basic != nil {
		n += m.Basic.Size()
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SymbolBasic_Bool) Size() (n int) {
	var l int
	_ = l
	n += 2
	return n
}
func (m *SymbolBasic_String_) Size() (n int) {
	var l int
	_ = l
	l = len(m.String_)
	n += 1 + l + sovSymbol(uint64(l))
	return n
}
func (m *SymbolBasic_Int8) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovSymbol(uint64(m.Int8))
	return n
}
func (m *SymbolBasic_Int16) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovSymbol(uint64(m.Int16))
	return n
}
func (m *SymbolBasic_Int32) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovSymbol(uint64(m.Int32))
	return n
}
func (m *SymbolBasic_Int64) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovSymbol(uint64(m.Int64))
	return n
}
func (m *SymbolBasic_Uint8) Size() (n int) {
	var l int
	_ = l
	n += 2 + sovSymbol(uint64(m.Uint8))
	return n
}
func (m *SymbolBasic_Uint16) Size() (n int) {
	var l int
	_ = l
	n += 2 + sovSymbol(uint64(m.Uint16))
	return n
}
func (m *SymbolBasic_Uint32) Size() (n int) {
	var l int
	_ = l
	n += 2 + sovSymbol(uint64(m.Uint32))
	return n
}
func (m *SymbolBasic_Uint64) Size() (n int) {
	var l int
	_ = l
	n += 2 + sovSymbol(uint64(m.Uint64))
	return n
}
func (m *SymbolBasic_Float32) Size() (n int) {
	var l int
	_ = l
	n += 6
	return n
}
func (m *SymbolBasic_Float64) Size() (n int) {
	var l int
	_ = l
	n += 10
	return n
}
func (m *SymbolSeries) Size() (n int) {
	var l int
	_ = l
	if len(m.Element) > 0 {
		for _, e := range m.Element {
			l = e.Size()
			n += 1 + l + sovSymbol(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SymbolStruct) Size() (n int) {
	var l int
	_ = l
	if len(m.Field) > 0 {
		for _, e := range m.Field {
			l = e.Size()
			n += 1 + l + sovSymbol(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SymbolField) Size() (n int) {
	var l int
	_ = l
	if m.Name != nil {
		l = len(*m.Name)
		n += 1 + l + sovSymbol(uint64(l))
	}
	if m.Monadic != nil {
		n += 2
	}
	if m.Value != nil {
		l = m.Value.Size()
		n += 1 + l + sovSymbol(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SymbolMap) Size() (n int) {
	var l int
	_ = l
	if len(m.KeyValue) > 0 {
		for _, e := range m.KeyValue {
			l = e.Size()
			n += 1 + l + sovSymbol(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SymbolKeyValue) Size() (n int) {
	var l int
	_ = l
	if m.Key != nil {
		l = len(*m.Key)
		n += 1 + l + sovSymbol(uint64(l))
	}
	if m.Value != nil {
		l = m.Value.Size()
		n += 1 + l + sovSymbol(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SymbolBlob) Size() (n int) {
	var l int
	_ = l
	if m.Bytes != nil {
		l = len(m.Bytes)
		n += 1 + l + sovSymbol(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovSymbol(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozSymbol(x uint64) (n int) {
	return sovSymbol(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Symbol) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSymbol
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Symbol: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Symbol: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Empty", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSymbol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSymbol
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &SymbolEmpty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Symbol = &Symbol_Empty{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Basic", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSymbol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSymbol
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &SymbolBasic{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Symbol = &Symbol_Basic{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Series", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSymbol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSymbol
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &SymbolSeries{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Symbol = &Symbol_Series{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Struct", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSymbol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSymbol
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &SymbolStruct{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Symbol = &Symbol_Struct{v}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Map", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSymbol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSymbol
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &SymbolMap{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Symbol = &Symbol_Map{v}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Blob", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSymbol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSymbol
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &SymbolBlob{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Symbol = &Symbol_Blob{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSymbol(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSymbol
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SymbolEmpty) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSymbol
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SymbolEmpty: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SymbolEmpty: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipSymbol(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSymbol
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SymbolBasic) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSymbol
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SymbolBasic: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SymbolBasic: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bool", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSymbol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Basic = &SymbolBasic_Bool{b}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field String_", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSymbol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSymbol
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Basic = &SymbolBasic_String_{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Int8", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSymbol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Basic = &SymbolBasic_Int8{v}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Int16", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSymbol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Basic = &SymbolBasic_Int16{v}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Int32", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSymbol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Basic = &SymbolBasic_Int32{v}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Int64", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSymbol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Basic = &SymbolBasic_Int64{v}
		case 20:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uint8", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSymbol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Basic = &SymbolBasic_Uint8{v}
		case 21:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uint16", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSymbol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Basic = &SymbolBasic_Uint16{v}
		case 22:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uint32", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSymbol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Basic = &SymbolBasic_Uint32{v}
		case 23:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uint64", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSymbol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Basic = &SymbolBasic_Uint64{v}
		case 30:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Float32", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Basic = &SymbolBasic_Float32{float32(math.Float32frombits(v))}
		case 31:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Float64", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Basic = &SymbolBasic_Float64{float64(math.Float64frombits(v))}
		default:
			iNdEx = preIndex
			skippy, err := skipSymbol(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSymbol
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SymbolSeries) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSymbol
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SymbolSeries: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SymbolSeries: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Element", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSymbol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSymbol
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Element = append(m.Element, &Symbol{})
			if err := m.Element[len(m.Element)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSymbol(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSymbol
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SymbolStruct) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSymbol
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SymbolStruct: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SymbolStruct: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Field", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSymbol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSymbol
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Field = append(m.Field, &SymbolField{})
			if err := m.Field[len(m.Field)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSymbol(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSymbol
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SymbolField) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSymbol
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SymbolField: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SymbolField: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSymbol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSymbol
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Name = &s
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Monadic", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSymbol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Monadic = &b
			hasFields[0] |= uint64(0x00000002)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSymbol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSymbol
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Value == nil {
				m.Value = &Symbol{}
			}
			if err := m.Value.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSymbol(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSymbol
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return new(proto1.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return new(proto1.RequiredNotSetError)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SymbolMap) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSymbol
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SymbolMap: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SymbolMap: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyValue", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSymbol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSymbol
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.KeyValue = append(m.KeyValue, &SymbolKeyValue{})
			if err := m.KeyValue[len(m.KeyValue)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSymbol(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSymbol
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SymbolKeyValue) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSymbol
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SymbolKeyValue: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SymbolKeyValue: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSymbol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSymbol
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Key = &s
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSymbol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSymbol
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Value == nil {
				m.Value = &Symbol{}
			}
			if err := m.Value.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000002)
		default:
			iNdEx = preIndex
			skippy, err := skipSymbol(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSymbol
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return new(proto1.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return new(proto1.RequiredNotSetError)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SymbolBlob) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSymbol
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SymbolBlob: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SymbolBlob: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bytes", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSymbol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthSymbol
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Bytes = append(m.Bytes[:0], dAtA[iNdEx:postIndex]...)
			if m.Bytes == nil {
				m.Bytes = []byte{}
			}
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		default:
			iNdEx = preIndex
			skippy, err := skipSymbol(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSymbol
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return new(proto1.RequiredNotSetError)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipSymbol(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowSymbol
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowSymbol
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowSymbol
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthSymbol
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowSymbol
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipSymbol(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthSymbol = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowSymbol   = fmt.Errorf("proto: integer overflow")
)

func init() { proto1.RegisterFile("symbol.proto", fileDescriptorSymbol) }

var fileDescriptorSymbol = []byte{
	// 545 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x7c, 0x94, 0x4f, 0x8b, 0xd3, 0x40,
	0x18, 0xc6, 0x33, 0x69, 0xd3, 0x3f, 0x6f, 0xbb, 0xa2, 0x43, 0xb7, 0x1d, 0x3d, 0xd4, 0x90, 0x8b,
	0x81, 0x95, 0xc2, 0xa6, 0x21, 0x08, 0x7a, 0xaa, 0x28, 0x85, 0xc5, 0xcb, 0x2c, 0x78, 0xf0, 0x22,
	0xc9, 0x76, 0x76, 0x09, 0x4d, 0x32, 0xa5, 0x4d, 0x85, 0x7c, 0x13, 0xbf, 0x85, 0xdf, 0xc1, 0x93,
	0x47, 0x3f, 0x82, 0xd4, 0x2f, 0x22, 0xf3, 0xce, 0xa4, 0x5b, 0x89, 0xeb, 0x6d, 0xde, 0xe7, 0xf9,
	0x3d, 0xe9, 0x93, 0xc9, 0x4b, 0x61, 0xb8, 0xab, 0xf2, 0x44, 0x66, 0xb3, 0xcd, 0x56, 0x96, 0x92,
	0xf6, 0xd7, 0x72, 0xa6, 0x05, 0xef, 0x9b, 0x0d, 0x9d, 0x6b, 0x3c, 0xd2, 0x19, 0x38, 0x22, 0xdf,
	0x94, 0x15, 0x23, 0x2e, 0xf1, 0x07, 0xc1, 0x78, 0x76, 0xa4, 0x66, 0x9a, 0x78, 0xa7, 0xdc, 0xa5,
	0xc5, 0x35, 0xa6, 0xf8, 0x24, 0xde, 0xa5, 0x37, 0xcc, 0x7e, 0x80, 0x5f, 0x28, 0x57, 0xf1, 0x88,
	0xd1, 0x4b, 0xe8, 0xec, 0xc4, 0x36, 0x15, 0x3b, 0xd6, 0xc2, 0xc0, 0xa4, 0x11, 0xb8, 0x46, 0x7b,
	0x69, 0x71, 0x03, 0x62, 0xa4, 0xdc, 0xee, 0x6f, 0x4a, 0xd6, 0x7e, 0x28, 0x82, 0x36, 0x46, 0xf0,
	0x44, 0x7d, 0x68, 0xe5, 0xf1, 0x86, 0x39, 0xc8, 0x8f, 0x1a, 0xfc, 0x87, 0x78, 0xb3, 0xb4, 0xb8,
	0x42, 0xe8, 0x05, 0xb4, 0x93, 0x4c, 0x26, 0xac, 0x83, 0xe8, 0x79, 0xb3, 0x7e, 0x26, 0x93, 0xa5,
	0xc5, 0x11, 0x5a, 0xf4, 0xa0, 0x63, 0x6e, 0xec, 0x0c, 0x06, 0x27, 0xd7, 0xe1, 0x7d, 0xb7, 0xeb,
	0x19, 0x5f, 0x97, 0x8e, 0xa0, 0x9d, 0x48, 0x99, 0xe1, 0x25, 0xf6, 0x30, 0x2e, 0x65, 0x46, 0x19,
	0xbe, 0x48, 0x5a, 0xdc, 0xe1, 0x65, 0xf5, 0x4d, 0xdf, 0xb4, 0xb8, 0x53, 0x7c, 0x5a, 0x94, 0xaf,
	0x18, 0xb8, 0xc4, 0x77, 0x14, 0xaf, 0x26, 0x3a, 0x06, 0x27, 0x2d, 0xca, 0xcb, 0x88, 0x0d, 0x8c,
	0xac, 0x47, 0xa3, 0xcf, 0x03, 0x36, 0x3c, 0xd1, 0xe7, 0x81, 0xd1, 0xa3, 0x90, 0x9d, 0xb9, 0xc4,
	0x6f, 0x19, 0x3d, 0x0a, 0x95, 0xbe, 0xc7, 0xc7, 0x8f, 0x5c, 0xe2, 0x9f, 0x29, 0x1d, 0x47, 0xd5,
	0x67, 0xaf, 0x7f, 0xe0, 0xdc, 0x18, 0x66, 0xae, 0x9d, 0x79, 0xc0, 0xc6, 0xa7, 0xce, 0x3c, 0xa8,
	0x9d, 0x28, 0x64, 0x13, 0x97, 0xf8, 0xed, 0xda, 0x89, 0x42, 0xfa, 0x0c, 0xba, 0xb7, 0x99, 0x8c,
	0x55, 0x68, 0xea, 0x12, 0xdf, 0x5e, 0x5a, 0xbc, 0x16, 0x8e, 0x5e, 0x14, 0xb2, 0xe7, 0x2e, 0xf1,
	0xc9, 0xd1, 0x8b, 0xc2, 0x45, 0xd7, 0x6c, 0x90, 0xf7, 0x1a, 0x86, 0xa7, 0x1b, 0x40, 0x2f, 0xa0,
	0x2b, 0x32, 0x91, 0x8b, 0xa2, 0x64, 0xc4, 0x6d, 0xf9, 0x83, 0xe0, 0x49, 0xe3, 0xeb, 0xf0, 0x9a,
	0xf0, 0xde, 0x1c, 0xc3, 0x7a, 0x03, 0x5e, 0x82, 0x73, 0x9b, 0x8a, 0x6c, 0x65, 0xa2, 0xcd, 0xbd,
	0x7c, 0xaf, 0x5c, 0xae, 0x21, 0x6f, 0x55, 0x7f, 0x3e, 0x54, 0x29, 0x85, 0x76, 0x11, 0xe7, 0x82,
	0x11, 0xd7, 0xf6, 0xfb, 0x1c, 0xcf, 0x94, 0x41, 0x37, 0x97, 0x45, 0xbc, 0xc2, 0x55, 0xb7, 0xfd,
	0x1e, 0xaf, 0x47, 0xfa, 0x02, 0x9c, 0x2f, 0x71, 0xb6, 0x17, 0x66, 0xa3, 0xff, 0xd1, 0x52, 0xfb,
	0xde, 0x5b, 0xe8, 0x1f, 0xf7, 0x8f, 0x46, 0xd0, 0x5f, 0x8b, 0xea, 0xb3, 0x4e, 0xea, 0x92, 0x4f,
	0x1b, 0xc9, 0x2b, 0x51, 0x7d, 0x54, 0x00, 0xef, 0xad, 0xcd, 0xc9, 0xbb, 0x82, 0x47, 0x7f, 0x7b,
	0xf4, 0x31, 0xb4, 0xd6, 0xa2, 0x32, 0x65, 0xd5, 0xf1, 0xbe, 0x91, 0x6a, 0xfa, 0xbf, 0x46, 0x1e,
	0xc0, 0xfd, 0x9a, 0xd3, 0x11, 0x38, 0x49, 0x55, 0x8a, 0x1d, 0x3e, 0x6a, 0xc8, 0xf5, 0xb0, 0x98,
	0xfc, 0x38, 0x4c, 0xc9, 0xcf, 0xc3, 0x94, 0xfc, 0x3a, 0x4c, 0xc9, 0xd7, 0xdf, 0x53, 0xeb, 0x93,
	0x83, 0x7f, 0x20, 0x7f, 0x02, 0x00, 0x00, 0xff, 0xff, 0xb8, 0xdc, 0xa1, 0x3c, 0x4f, 0x04, 0x00,
	0x00,
}
