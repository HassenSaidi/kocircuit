// Node constructs a red-black binary search tree node.
Node(value, color, left, right) {
	return: (
		value: Expect(value) // any user type
		color: Expect(color) // Red or Black
		left: left // optional left child node
		right: right // optional right child node
	)
}

Red() { return: Empty() }

Black() { return: Empty() }

RotateLeft(node?) {
	return: When(
		have: All(node: node, nodeRight: node.right)
		then: rotateLeft(all?) {
			return: Node(
				value: all.nodeRight.value
				color: all.node.color
				left: Node(
					value: all.node.value, color: all.nodeRight.color
					left: all.node.left, right: all.nodeRight.left
				)
				right: all.nodeRight.right
			)
		}
		else: Panic[msg: "node cannot be rotated left", node: node]
	)
}

RotateRight(node?) {
	return: When(
		have: All(nodeLeft: node.left, node: node)
		then: rotateRight(all?) {
			return: Node(
				value: all.nodeLeft.value
				color: all.node.color
				left: all.nodeLeft.left
				right: Node(
					value: all.node.value, color: all.nodeLeft.color
					left: all.nodeLeft.right, right: all.node.right
				)
			)
		}
		else: Panic[msg: "node cannot be rotated right", node: node]
	)
}

Flip(node?) {
	return: When(
		have: All(nodeLeft: node.left, node: node, nodeRight: node.right)
		then: flip
		else: Panic[msg: "node cannot be flipped", node: node]
	)
}

flip(all?) {
	return: Node(
		value: all.node.value
		color: flipColor(all.node.color)
		left: flipNodeColor(all.nodeLeft)
		right: flipNodeColor(all.nodeRight)
	)
}

flipColor(color?) {
	return: Switch(
		case: Yield[if: Equal(color, Red), then: Black]
		case: Yield[if: Equal(color, Black), then: Red]
		otherwise: Panic[msg: "unknown color", color: color]
	)
}

flipNodeColor(node?) {
	return: Node(
		value: node.value
		color: flipColor(node.color)
		left: node.left
		right: node.right
	)
}

/*
Insert(node, value, Less) {
	return: When(
		have: node
		then: insert[value: value, Less: Less]
		else: Node[value: value, color: Red]
	)
}

insert(node?, value, Less) {
	step1: RedRedFlip(node)
	step2: XXX
	step3: BlackRedRotateLeft(step2)
	return: LeftRedRedRotateRight(step3)
}
*/

// If node has a left and a right node, and they are both red, then
// RedRedFlip flips the colors of all three nodes and returns the resulting node.
RedRedFlip(node?) {
	return: When(
		have: All(nodeLeft: node.left, node: node, nodeRight: node.right)
		then: redRedFlip(all?) {
			return: Branch(
				if: And(
					Equal(all.nodeLeft.color, Red)
					Equal(all.nodeRight.color, Red)
				)
				then: flip[all]
				else: Return[all.node]
			)
		}
		else: Return[node]
	)
}

BlackRedRotateLeft(node?) {
	return: When(
		have: All(nodeLeft: node.left, node: node, nodeRight: node.right)
		then: blackRedRotateLeft(all?) {
			return: Branch(
				if: And(
					Equal(all.nodeLeft.color, Black)
					Equal(all.nodeRight.color, Red)
				)
				then: rotateLeft[all]
				else: Return[all.node]
			)
		}
		else: Return[node]
	)
}

LeftRedRedRotateRight(node?) {
	return: When(
		have: All(nodeLeftLeft: node.left.left, nodeLeft: node.left, node: node)
		then: leftRedRedRotateRight(all?) {
			return: Branch(
				if: And(
					Equal(all.nodeLeftLeft.color, Red)
					Equal(all.nodeLeft.color, Red)
				)
				then: rotateRight[all]
				else: Return[all.node]
			)
		}
		else: Return[node]
	)
}
