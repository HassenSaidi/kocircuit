// Node constructs a red-black binary search tree node.
Node(value, color, left, right) {
	return: (
		value: Expect(value) // any user type
		color: Expect(color) // Red or Black
		left: left // optional left child node
		right: right // optional right child node
	)
}

Red() { return: Empty() }

Black() { return: Empty() }

RotateLeft(node?) {
	return: When(
		have: All(
			a: node.left
			b: node
			c: node.right.left
			d: node.right
			e: node.right.right
		)
		then: rotateLeft
		else: Panic[msg: "node cannot be rotated left", node: node]
	)
}

rotateLeft(abcde?) {
	return: Node(
		value: abcde.d.value
		color: abcde.b.color
		left: Node(
			value: abcde.b.value
			color: abcde.d.color
			left: abcde.a
			right: abcde.c
		)
		right: abcde.e
	)
}

RotateRight(node?) {
	return: When(
		have: All(
			a: node.left.left
			b: node.left
			c: node.left.right
			d: node
			e: node.right
		)
		then: rotateRight
		else: Panic[msg: "node cannot be rotated right", node: node]
	)
}

rotateRight(abcde?) {
	return: Node(
		value: abcde.b.value
		color: abcde.d.color
		left: abcde.a
		right: Node(
			value: abcde.d.value
			color: abcde.b.color
			left: abcde.c
			right: abcde.e
		)
	)
}

Flip(node?) {
	return: When(
		have: All(a: node.left, b: node, c: node.right)
		then: flip
		else: Panic[msg: "node cannot be flipped", node: node]
	)
}

flip(abc?) {
	return: Node(
		value: abc.b.value
		color: flipColor(abc.b.color)
		left: flipNodeColor(abc.a)
		right: flipNodeColor(abc.c)
	)
}

flipColor(color?) {
	return: Switch(
		case: Yield[if: Equal(color, Red), then: Black]
		case: Yield[if: Equal(color, Black), then: Red]
		otherwise: Panic[msg: "unknown color", color: color]
	)
}

flipNodeColor(node?) {
	return: Node(
		value: node.value
		color: flipColor(node.color)
		left: node.left
		right: node.right
	)
}
