// Node constructs a red-black binary search tree node.
Node(value, color, left, right) {
	return: (
		value: Expect(value) // any user type
		color: Expect(color) // Red or Black
		left: left // optional left child node
		right: right // optional right child node
	)
}

Red() { return: Empty() }

Black() { return: Empty() }

RotateLeft(node?) {
	return: When(
		have: All(a: node, b: node.right)
		then: rotateLeft
		else: Panic[msg: "node cannot be rotated left", node: node]
	)
}

rotateLeft(ab?) {
	return: Node(
		value: ab.b.value
		color: ab.a.color
		left: Node(
			value: ab.a.value, color: ab.b.color
			left: ab.a.left, right: ab.b.left
		)
		right: ab.b.right
	)
}

RotateRight(node?) {
	return: When(
		have: All(a: node.left, b: node)
		then: rotateRight
		else: Panic[msg: "node cannot be rotated right", node: node]
	)
}

rotateRight(ab?) {
	return: Node(
		value: ab.a.value
		color: ab.b.color
		left: ab.a.left
		right: Node(
			value: ab.b.value, color: ab.a.color
			left: ab.a.right, right: ab.b.right
		)
	)
}

Flip(node?) {
	return: When(
		have: All(a: node.left, b: node, c: node.right)
		then: flip
		else: Panic[msg: "node cannot be flipped", node: node]
	)
}

flip(abc?) {
	return: Node(
		value: abc.b.value
		color: flipColor(abc.b.color)
		left: flipNodeColor(abc.a)
		right: flipNodeColor(abc.c)
	)
}

flipColor(color?) {
	return: Switch(
		case: Yield[if: Equal(color, Red), then: Black]
		case: Yield[if: Equal(color, Black), then: Red]
		otherwise: Panic[msg: "unknown color", color: color]
	)
}

flipNodeColor(node?) {
	return: Node(
		value: node.value
		color: flipColor(node.color)
		left: node.left
		right: node.right
	)
}

/*
Insert(node, value, Less) {
	return: When(
		have: node
		then: insert[value: value, Less: Less]
		else: Node[value: value, color: Red]
	)
}

insert(node?, value, Less) {
	step1: RedRedFlip(node)
	step2: XXX
	step3: BlackRedRotateLeft(step2)
	return: XXX
}

// RedRedFlip implements "if (isRed(h.left) && isRed(h.right)), then colorFlip(h)"
RedRedFlip(node?) {
	return: When(
		have: All(a: node.left, b: node, c: node.right)
		then: redRedFlip[node: node]
		else: Return[node]
	)
}

redRedFlip(node, abc?) {
	return: Yield(
		if: And(Equal(a.color, Red), Equal(c.color, Red))
		then: flip(abc)
		else: node
	)
}

BlackRedRotateLeft(node?) {
	return: When(
		have: All(a: node.left, b: node, c: node.right)
		then: blackRedRotateLeft[node: node]
		else: Return[node]
	)
}

blackRedRotateLeft(node, abc?) {
	return: Yield(
		if: And(Equal(a.color, Black), Equal(c.color, Red))
		then: XXX
		else: node
	)
}
*/
